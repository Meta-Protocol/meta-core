// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zetachain/zetacore/crosschain/cross_chain_tx.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	coin "github.com/zeta-chain/node/pkg/coin"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CctxStatus int32

const (
	CctxStatus_PendingInbound  CctxStatus = 0
	CctxStatus_PendingOutbound CctxStatus = 1
	CctxStatus_OutboundMined   CctxStatus = 3
	CctxStatus_PendingRevert   CctxStatus = 4
	CctxStatus_Reverted        CctxStatus = 5
	CctxStatus_Aborted         CctxStatus = 6
)

var CctxStatus_name = map[int32]string{
	0: "PendingInbound",
	1: "PendingOutbound",
	3: "OutboundMined",
	4: "PendingRevert",
	5: "Reverted",
	6: "Aborted",
}

var CctxStatus_value = map[string]int32{
	"PendingInbound":  0,
	"PendingOutbound": 1,
	"OutboundMined":   3,
	"PendingRevert":   4,
	"Reverted":        5,
	"Aborted":         6,
}

func (x CctxStatus) String() string {
	return proto.EnumName(CctxStatus_name, int32(x))
}

func (CctxStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{0}
}

type TxFinalizationStatus int32

const (
	TxFinalizationStatus_NotFinalized TxFinalizationStatus = 0
	TxFinalizationStatus_Finalized    TxFinalizationStatus = 1
	TxFinalizationStatus_Executed     TxFinalizationStatus = 2
)

var TxFinalizationStatus_name = map[int32]string{
	0: "NotFinalized",
	1: "Finalized",
	2: "Executed",
}

var TxFinalizationStatus_value = map[string]int32{
	"NotFinalized": 0,
	"Finalized":    1,
	"Executed":     2,
}

func (x TxFinalizationStatus) String() string {
	return proto.EnumName(TxFinalizationStatus_name, int32(x))
}

func (TxFinalizationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{1}
}

type ConfirmationMode int32

const (
	ConfirmationMode_SAFE ConfirmationMode = 0
	ConfirmationMode_FAST ConfirmationMode = 1
)

var ConfirmationMode_name = map[int32]string{
	0: "SAFE",
	1: "FAST",
}

var ConfirmationMode_value = map[string]int32{
	"SAFE": 0,
	"FAST": 1,
}

func (x ConfirmationMode) String() string {
	return proto.EnumName(ConfirmationMode_name, int32(x))
}

func (ConfirmationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{2}
}

// InboundStatus represents the status of an observed inbound
type InboundStatus int32

const (
	InboundStatus_SUCCESS InboundStatus = 0
	// this field is specifically for Bitcoin when the deposit amount is less than
	// depositor fee
	InboundStatus_INSUFFICIENT_DEPOSITOR_FEE InboundStatus = 1
	// the receiver address parsed from the inbound is invalid
	InboundStatus_INVALID_RECEIVER_ADDRESS InboundStatus = 2
)

var InboundStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "INSUFFICIENT_DEPOSITOR_FEE",
	2: "INVALID_RECEIVER_ADDRESS",
}

var InboundStatus_value = map[string]int32{
	"SUCCESS":                    0,
	"INSUFFICIENT_DEPOSITOR_FEE": 1,
	"INVALID_RECEIVER_ADDRESS":   2,
}

func (x InboundStatus) String() string {
	return proto.EnumName(InboundStatus_name, int32(x))
}

func (InboundStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{3}
}

// ProtocolContractVersion represents the version of the protocol contract used
// for cctx workflow
type ProtocolContractVersion int32

const (
	ProtocolContractVersion_V1 ProtocolContractVersion = 0
	ProtocolContractVersion_V2 ProtocolContractVersion = 1
)

var ProtocolContractVersion_name = map[int32]string{
	0: "V1",
	1: "V2",
}

var ProtocolContractVersion_value = map[string]int32{
	"V1": 0,
	"V2": 1,
}

func (x ProtocolContractVersion) String() string {
	return proto.EnumName(ProtocolContractVersion_name, int32(x))
}

func (ProtocolContractVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{4}
}

type InboundParams struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// the Connector.send()
	SenderChainId          int64                  `protobuf:"varint,2,opt,name=sender_chain_id,json=senderChainId,proto3" json:"sender_chain_id,omitempty"`
	TxOrigin               string                 `protobuf:"bytes,3,opt,name=tx_origin,json=txOrigin,proto3" json:"tx_origin,omitempty"`
	CoinType               coin.CoinType          `protobuf:"varint,4,opt,name=coin_type,json=coinType,proto3,enum=zetachain.zetacore.pkg.coin.CoinType" json:"coin_type,omitempty"`
	Asset                  string                 `protobuf:"bytes,5,opt,name=asset,proto3" json:"asset,omitempty"`
	Amount                 cosmossdk_io_math.Uint `protobuf:"bytes,6,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	ObservedHash           string                 `protobuf:"bytes,7,opt,name=observed_hash,json=observedHash,proto3" json:"observed_hash,omitempty"`
	ObservedExternalHeight uint64                 `protobuf:"varint,8,opt,name=observed_external_height,json=observedExternalHeight,proto3" json:"observed_external_height,omitempty"`
	BallotIndex            string                 `protobuf:"bytes,9,opt,name=ballot_index,json=ballotIndex,proto3" json:"ballot_index,omitempty"`
	FinalizedZetaHeight    uint64                 `protobuf:"varint,10,opt,name=finalized_zeta_height,json=finalizedZetaHeight,proto3" json:"finalized_zeta_height,omitempty"`
	TxFinalizationStatus   TxFinalizationStatus   `protobuf:"varint,11,opt,name=tx_finalization_status,json=txFinalizationStatus,proto3,enum=zetachain.zetacore.crosschain.TxFinalizationStatus" json:"tx_finalization_status,omitempty"`
	// this field describes if a smart contract call should be made for a inbound
	// with assets only used for protocol contract version 2
	IsCrossChainCall bool `protobuf:"varint,12,opt,name=is_cross_chain_call,json=isCrossChainCall,proto3" json:"is_cross_chain_call,omitempty"`
	// confirmation mode used for the inbound
	ConfirmationMode ConfirmationMode `protobuf:"varint,13,opt,name=confirmation_mode,json=confirmationMode,proto3,enum=zetachain.zetacore.crosschain.ConfirmationMode" json:"confirmation_mode,omitempty"`
	// status of the inbound observation
	Status InboundStatus `protobuf:"varint,20,opt,name=status,proto3,enum=zetachain.zetacore.crosschain.InboundStatus" json:"status,omitempty"`
}

func (m *InboundParams) Reset()         { *m = InboundParams{} }
func (m *InboundParams) String() string { return proto.CompactTextString(m) }
func (*InboundParams) ProtoMessage()    {}
func (*InboundParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{0}
}
func (m *InboundParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InboundParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InboundParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InboundParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InboundParams.Merge(m, src)
}
func (m *InboundParams) XXX_Size() int {
	return m.Size()
}
func (m *InboundParams) XXX_DiscardUnknown() {
	xxx_messageInfo_InboundParams.DiscardUnknown(m)
}

var xxx_messageInfo_InboundParams proto.InternalMessageInfo

func (m *InboundParams) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *InboundParams) GetSenderChainId() int64 {
	if m != nil {
		return m.SenderChainId
	}
	return 0
}

func (m *InboundParams) GetTxOrigin() string {
	if m != nil {
		return m.TxOrigin
	}
	return ""
}

func (m *InboundParams) GetCoinType() coin.CoinType {
	if m != nil {
		return m.CoinType
	}
	return coin.CoinType_Zeta
}

func (m *InboundParams) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *InboundParams) GetObservedHash() string {
	if m != nil {
		return m.ObservedHash
	}
	return ""
}

func (m *InboundParams) GetObservedExternalHeight() uint64 {
	if m != nil {
		return m.ObservedExternalHeight
	}
	return 0
}

func (m *InboundParams) GetBallotIndex() string {
	if m != nil {
		return m.BallotIndex
	}
	return ""
}

func (m *InboundParams) GetFinalizedZetaHeight() uint64 {
	if m != nil {
		return m.FinalizedZetaHeight
	}
	return 0
}

func (m *InboundParams) GetTxFinalizationStatus() TxFinalizationStatus {
	if m != nil {
		return m.TxFinalizationStatus
	}
	return TxFinalizationStatus_NotFinalized
}

func (m *InboundParams) GetIsCrossChainCall() bool {
	if m != nil {
		return m.IsCrossChainCall
	}
	return false
}

func (m *InboundParams) GetConfirmationMode() ConfirmationMode {
	if m != nil {
		return m.ConfirmationMode
	}
	return ConfirmationMode_SAFE
}

func (m *InboundParams) GetStatus() InboundStatus {
	if m != nil {
		return m.Status
	}
	return InboundStatus_SUCCESS
}

type ZetaAccounting struct {
	// aborted_zeta_amount stores the total aborted amount for cctx of coin-type
	// ZETA
	AbortedZetaAmount cosmossdk_io_math.Uint `protobuf:"bytes,1,opt,name=aborted_zeta_amount,json=abortedZetaAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"aborted_zeta_amount"`
}

func (m *ZetaAccounting) Reset()         { *m = ZetaAccounting{} }
func (m *ZetaAccounting) String() string { return proto.CompactTextString(m) }
func (*ZetaAccounting) ProtoMessage()    {}
func (*ZetaAccounting) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{1}
}
func (m *ZetaAccounting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZetaAccounting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZetaAccounting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZetaAccounting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZetaAccounting.Merge(m, src)
}
func (m *ZetaAccounting) XXX_Size() int {
	return m.Size()
}
func (m *ZetaAccounting) XXX_DiscardUnknown() {
	xxx_messageInfo_ZetaAccounting.DiscardUnknown(m)
}

var xxx_messageInfo_ZetaAccounting proto.InternalMessageInfo

type CallOptions struct {
	GasLimit        uint64 `protobuf:"varint,1,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	IsArbitraryCall bool   `protobuf:"varint,2,opt,name=is_arbitrary_call,json=isArbitraryCall,proto3" json:"is_arbitrary_call,omitempty"`
}

func (m *CallOptions) Reset()         { *m = CallOptions{} }
func (m *CallOptions) String() string { return proto.CompactTextString(m) }
func (*CallOptions) ProtoMessage()    {}
func (*CallOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{2}
}
func (m *CallOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallOptions.Merge(m, src)
}
func (m *CallOptions) XXX_Size() int {
	return m.Size()
}
func (m *CallOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CallOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CallOptions proto.InternalMessageInfo

func (m *CallOptions) GetGasLimit() uint64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *CallOptions) GetIsArbitraryCall() bool {
	if m != nil {
		return m.IsArbitraryCall
	}
	return false
}

type OutboundParams struct {
	Receiver        string                 `protobuf:"bytes,1,opt,name=receiver,proto3" json:"receiver,omitempty"`
	ReceiverChainId int64                  `protobuf:"varint,2,opt,name=receiver_chainId,json=receiverChainId,proto3" json:"receiver_chainId,omitempty"`
	CoinType        coin.CoinType          `protobuf:"varint,3,opt,name=coin_type,json=coinType,proto3,enum=zetachain.zetacore.pkg.coin.CoinType" json:"coin_type,omitempty"`
	Amount          cosmossdk_io_math.Uint `protobuf:"bytes,4,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	TssNonce        uint64                 `protobuf:"varint,5,opt,name=tss_nonce,json=tssNonce,proto3" json:"tss_nonce,omitempty"`
	// Deprecated (v21), use CallOptions
	GasLimit       uint64 `protobuf:"varint,6,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasPrice       string `protobuf:"bytes,7,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	GasPriorityFee string `protobuf:"bytes,23,opt,name=gas_priority_fee,json=gasPriorityFee,proto3" json:"gas_priority_fee,omitempty"`
	// the above are commands for zetaclients
	// the following fields are used when the outbound tx is mined
	Hash                   string                `protobuf:"bytes,8,opt,name=hash,proto3" json:"hash,omitempty"`
	BallotIndex            string                `protobuf:"bytes,9,opt,name=ballot_index,json=ballotIndex,proto3" json:"ballot_index,omitempty"`
	ObservedExternalHeight uint64                `protobuf:"varint,10,opt,name=observed_external_height,json=observedExternalHeight,proto3" json:"observed_external_height,omitempty"`
	GasUsed                uint64                `protobuf:"varint,20,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	EffectiveGasPrice      cosmossdk_io_math.Int `protobuf:"bytes,21,opt,name=effective_gas_price,json=effectiveGasPrice,proto3,customtype=cosmossdk.io/math.Int" json:"effective_gas_price"`
	EffectiveGasLimit      uint64                `protobuf:"varint,22,opt,name=effective_gas_limit,json=effectiveGasLimit,proto3" json:"effective_gas_limit,omitempty"`
	TssPubkey              string                `protobuf:"bytes,11,opt,name=tss_pubkey,json=tssPubkey,proto3" json:"tss_pubkey,omitempty"`
	TxFinalizationStatus   TxFinalizationStatus  `protobuf:"varint,12,opt,name=tx_finalization_status,json=txFinalizationStatus,proto3,enum=zetachain.zetacore.crosschain.TxFinalizationStatus" json:"tx_finalization_status,omitempty"`
	CallOptions            *CallOptions          `protobuf:"bytes,24,opt,name=call_options,json=callOptions,proto3" json:"call_options,omitempty"`
	// confirmation mode used for the outbound
	ConfirmationMode ConfirmationMode `protobuf:"varint,25,opt,name=confirmation_mode,json=confirmationMode,proto3,enum=zetachain.zetacore.crosschain.ConfirmationMode" json:"confirmation_mode,omitempty"`
}

func (m *OutboundParams) Reset()         { *m = OutboundParams{} }
func (m *OutboundParams) String() string { return proto.CompactTextString(m) }
func (*OutboundParams) ProtoMessage()    {}
func (*OutboundParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{3}
}
func (m *OutboundParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutboundParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutboundParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutboundParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutboundParams.Merge(m, src)
}
func (m *OutboundParams) XXX_Size() int {
	return m.Size()
}
func (m *OutboundParams) XXX_DiscardUnknown() {
	xxx_messageInfo_OutboundParams.DiscardUnknown(m)
}

var xxx_messageInfo_OutboundParams proto.InternalMessageInfo

func (m *OutboundParams) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func (m *OutboundParams) GetReceiverChainId() int64 {
	if m != nil {
		return m.ReceiverChainId
	}
	return 0
}

func (m *OutboundParams) GetCoinType() coin.CoinType {
	if m != nil {
		return m.CoinType
	}
	return coin.CoinType_Zeta
}

func (m *OutboundParams) GetTssNonce() uint64 {
	if m != nil {
		return m.TssNonce
	}
	return 0
}

func (m *OutboundParams) GetGasLimit() uint64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *OutboundParams) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *OutboundParams) GetGasPriorityFee() string {
	if m != nil {
		return m.GasPriorityFee
	}
	return ""
}

func (m *OutboundParams) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *OutboundParams) GetBallotIndex() string {
	if m != nil {
		return m.BallotIndex
	}
	return ""
}

func (m *OutboundParams) GetObservedExternalHeight() uint64 {
	if m != nil {
		return m.ObservedExternalHeight
	}
	return 0
}

func (m *OutboundParams) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *OutboundParams) GetEffectiveGasLimit() uint64 {
	if m != nil {
		return m.EffectiveGasLimit
	}
	return 0
}

func (m *OutboundParams) GetTssPubkey() string {
	if m != nil {
		return m.TssPubkey
	}
	return ""
}

func (m *OutboundParams) GetTxFinalizationStatus() TxFinalizationStatus {
	if m != nil {
		return m.TxFinalizationStatus
	}
	return TxFinalizationStatus_NotFinalized
}

func (m *OutboundParams) GetCallOptions() *CallOptions {
	if m != nil {
		return m.CallOptions
	}
	return nil
}

func (m *OutboundParams) GetConfirmationMode() ConfirmationMode {
	if m != nil {
		return m.ConfirmationMode
	}
	return ConfirmationMode_SAFE
}

type Status struct {
	Status CctxStatus `protobuf:"varint,1,opt,name=status,proto3,enum=zetachain.zetacore.crosschain.CctxStatus" json:"status,omitempty"`
	// status_message carries information about the status transitions:
	// why they were triggered, old and new status.
	StatusMessage string `protobuf:"bytes,2,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"`
	// error_message carries information about the error that caused the tx
	// to be PendingRevert, Reverted or Aborted.
	ErrorMessage        string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	LastUpdateTimestamp int64  `protobuf:"varint,3,opt,name=lastUpdate_timestamp,json=lastUpdateTimestamp,proto3" json:"lastUpdate_timestamp,omitempty"`
	IsAbortRefunded     bool   `protobuf:"varint,4,opt,name=isAbortRefunded,proto3" json:"isAbortRefunded,omitempty"`
	// when the CCTX was created. only populated on new transactions.
	CreatedTimestamp int64 `protobuf:"varint,5,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
	// error_message_revert carries information about the revert outbound tx ,
	// which is created if the first outbound tx fails
	ErrorMessageRevert string `protobuf:"bytes,7,opt,name=error_message_revert,json=errorMessageRevert,proto3" json:"error_message_revert,omitempty"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{4}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetStatus() CctxStatus {
	if m != nil {
		return m.Status
	}
	return CctxStatus_PendingInbound
}

func (m *Status) GetStatusMessage() string {
	if m != nil {
		return m.StatusMessage
	}
	return ""
}

func (m *Status) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *Status) GetLastUpdateTimestamp() int64 {
	if m != nil {
		return m.LastUpdateTimestamp
	}
	return 0
}

func (m *Status) GetIsAbortRefunded() bool {
	if m != nil {
		return m.IsAbortRefunded
	}
	return false
}

func (m *Status) GetCreatedTimestamp() int64 {
	if m != nil {
		return m.CreatedTimestamp
	}
	return 0
}

func (m *Status) GetErrorMessageRevert() string {
	if m != nil {
		return m.ErrorMessageRevert
	}
	return ""
}

// RevertOptions represents the options for reverting a cctx
type RevertOptions struct {
	RevertAddress  string                 `protobuf:"bytes,1,opt,name=revert_address,json=revertAddress,proto3" json:"revert_address,omitempty"`
	CallOnRevert   bool                   `protobuf:"varint,2,opt,name=call_on_revert,json=callOnRevert,proto3" json:"call_on_revert,omitempty"`
	AbortAddress   string                 `protobuf:"bytes,3,opt,name=abort_address,json=abortAddress,proto3" json:"abort_address,omitempty"`
	RevertMessage  []byte                 `protobuf:"bytes,4,opt,name=revert_message,json=revertMessage,proto3" json:"revert_message,omitempty"`
	RevertGasLimit cosmossdk_io_math.Uint `protobuf:"bytes,5,opt,name=revert_gas_limit,json=revertGasLimit,proto3,customtype=cosmossdk.io/math.Uint" json:"revert_gas_limit"`
}

func (m *RevertOptions) Reset()         { *m = RevertOptions{} }
func (m *RevertOptions) String() string { return proto.CompactTextString(m) }
func (*RevertOptions) ProtoMessage()    {}
func (*RevertOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{5}
}
func (m *RevertOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevertOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevertOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevertOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevertOptions.Merge(m, src)
}
func (m *RevertOptions) XXX_Size() int {
	return m.Size()
}
func (m *RevertOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RevertOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RevertOptions proto.InternalMessageInfo

func (m *RevertOptions) GetRevertAddress() string {
	if m != nil {
		return m.RevertAddress
	}
	return ""
}

func (m *RevertOptions) GetCallOnRevert() bool {
	if m != nil {
		return m.CallOnRevert
	}
	return false
}

func (m *RevertOptions) GetAbortAddress() string {
	if m != nil {
		return m.AbortAddress
	}
	return ""
}

func (m *RevertOptions) GetRevertMessage() []byte {
	if m != nil {
		return m.RevertMessage
	}
	return nil
}

type CrossChainTx struct {
	Creator                 string                  `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Index                   string                  `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	ZetaFees                cosmossdk_io_math.Uint  `protobuf:"bytes,5,opt,name=zeta_fees,json=zetaFees,proto3,customtype=cosmossdk.io/math.Uint" json:"zeta_fees" yaml:"zeta_fees"`
	RelayedMessage          string                  `protobuf:"bytes,6,opt,name=relayed_message,json=relayedMessage,proto3" json:"relayed_message,omitempty"`
	CctxStatus              *Status                 `protobuf:"bytes,8,opt,name=cctx_status,json=cctxStatus,proto3" json:"cctx_status,omitempty"`
	InboundParams           *InboundParams          `protobuf:"bytes,9,opt,name=inbound_params,json=inboundParams,proto3" json:"inbound_params,omitempty"`
	OutboundParams          []*OutboundParams       `protobuf:"bytes,10,rep,name=outbound_params,json=outboundParams,proto3" json:"outbound_params,omitempty"`
	ProtocolContractVersion ProtocolContractVersion `protobuf:"varint,11,opt,name=protocol_contract_version,json=protocolContractVersion,proto3,enum=zetachain.zetacore.crosschain.ProtocolContractVersion" json:"protocol_contract_version,omitempty"`
	RevertOptions           RevertOptions           `protobuf:"bytes,12,opt,name=revert_options,json=revertOptions,proto3" json:"revert_options"`
}

func (m *CrossChainTx) Reset()         { *m = CrossChainTx{} }
func (m *CrossChainTx) String() string { return proto.CompactTextString(m) }
func (*CrossChainTx) ProtoMessage()    {}
func (*CrossChainTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4c1966807fb5cb2, []int{6}
}
func (m *CrossChainTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainTx.Merge(m, src)
}
func (m *CrossChainTx) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainTx) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainTx.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainTx proto.InternalMessageInfo

func (m *CrossChainTx) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *CrossChainTx) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *CrossChainTx) GetRelayedMessage() string {
	if m != nil {
		return m.RelayedMessage
	}
	return ""
}

func (m *CrossChainTx) GetCctxStatus() *Status {
	if m != nil {
		return m.CctxStatus
	}
	return nil
}

func (m *CrossChainTx) GetInboundParams() *InboundParams {
	if m != nil {
		return m.InboundParams
	}
	return nil
}

func (m *CrossChainTx) GetOutboundParams() []*OutboundParams {
	if m != nil {
		return m.OutboundParams
	}
	return nil
}

func (m *CrossChainTx) GetProtocolContractVersion() ProtocolContractVersion {
	if m != nil {
		return m.ProtocolContractVersion
	}
	return ProtocolContractVersion_V1
}

func (m *CrossChainTx) GetRevertOptions() RevertOptions {
	if m != nil {
		return m.RevertOptions
	}
	return RevertOptions{}
}

func init() {
	proto.RegisterEnum("zetachain.zetacore.crosschain.CctxStatus", CctxStatus_name, CctxStatus_value)
	proto.RegisterEnum("zetachain.zetacore.crosschain.TxFinalizationStatus", TxFinalizationStatus_name, TxFinalizationStatus_value)
	proto.RegisterEnum("zetachain.zetacore.crosschain.ConfirmationMode", ConfirmationMode_name, ConfirmationMode_value)
	proto.RegisterEnum("zetachain.zetacore.crosschain.InboundStatus", InboundStatus_name, InboundStatus_value)
	proto.RegisterEnum("zetachain.zetacore.crosschain.ProtocolContractVersion", ProtocolContractVersion_name, ProtocolContractVersion_value)
	proto.RegisterType((*InboundParams)(nil), "zetachain.zetacore.crosschain.InboundParams")
	proto.RegisterType((*ZetaAccounting)(nil), "zetachain.zetacore.crosschain.ZetaAccounting")
	proto.RegisterType((*CallOptions)(nil), "zetachain.zetacore.crosschain.CallOptions")
	proto.RegisterType((*OutboundParams)(nil), "zetachain.zetacore.crosschain.OutboundParams")
	proto.RegisterType((*Status)(nil), "zetachain.zetacore.crosschain.Status")
	proto.RegisterType((*RevertOptions)(nil), "zetachain.zetacore.crosschain.RevertOptions")
	proto.RegisterType((*CrossChainTx)(nil), "zetachain.zetacore.crosschain.CrossChainTx")
}

func init() {
	proto.RegisterFile("zetachain/zetacore/crosschain/cross_chain_tx.proto", fileDescriptor_d4c1966807fb5cb2)
}

var fileDescriptor_d4c1966807fb5cb2 = []byte{
	// 1540 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0xe6, 0x48, 0x14, 0x45, 0x16, 0x7f, 0x34, 0x6a, 0xd1, 0xf2, 0x58, 0x89, 0x69, 0x85, 0x89,
	0x37, 0x5c, 0x67, 0x4d, 0x66, 0xb5, 0xc0, 0x22, 0xc8, 0x8d, 0xa6, 0xc8, 0x35, 0x93, 0xd5, 0x0f,
	0x86, 0x92, 0x80, 0x2c, 0x02, 0xcc, 0x36, 0x67, 0x5a, 0x64, 0xc3, 0xe4, 0x34, 0x31, 0xdd, 0x14,
	0xa8, 0x45, 0x1e, 0x22, 0x0f, 0x90, 0x63, 0x0e, 0x79, 0x94, 0x3d, 0x2e, 0x90, 0x4b, 0x90, 0x83,
	0x11, 0xd8, 0x6f, 0xe0, 0x73, 0x0e, 0x41, 0xff, 0xf1, 0x47, 0x51, 0x24, 0x65, 0xe1, 0x13, 0xbb,
	0xab, 0xba, 0xbe, 0x2e, 0x56, 0xd7, 0xf7, 0x75, 0x0f, 0x1c, 0x7c, 0x47, 0x04, 0x0e, 0x87, 0x98,
	0xc6, 0x0d, 0x35, 0x62, 0x09, 0x69, 0x84, 0x09, 0xe3, 0x5c, 0xdb, 0xd4, 0x30, 0x50, 0xe3, 0x40,
	0xcc, 0xea, 0x93, 0x84, 0x09, 0x86, 0x9e, 0xce, 0x63, 0xea, 0x36, 0xa6, 0xbe, 0x88, 0xd9, 0x2b,
	0x0f, 0xd8, 0x80, 0xa9, 0x95, 0x0d, 0x39, 0xd2, 0x41, 0x7b, 0x9f, 0xdc, 0xb2, 0xd1, 0xe4, 0xcd,
	0xa0, 0x11, 0x32, 0xb9, 0x0d, 0xa3, 0xb1, 0x5e, 0x57, 0xfd, 0xb0, 0x01, 0xc5, 0x6e, 0xdc, 0x67,
	0xd3, 0x38, 0x3a, 0xc5, 0x09, 0x1e, 0x73, 0xb4, 0x0b, 0x19, 0x4e, 0xe2, 0x88, 0x24, 0x9e, 0xb3,
	0xef, 0xd4, 0x72, 0xbe, 0x99, 0xa1, 0x4f, 0x60, 0x4b, 0x8f, 0x4c, 0x7e, 0x34, 0xf2, 0xd6, 0xf6,
	0x9d, 0xda, 0xba, 0x5f, 0xd4, 0xe6, 0x96, 0xb4, 0x76, 0x23, 0xf4, 0x13, 0xc8, 0x89, 0x59, 0xc0,
	0x12, 0x3a, 0xa0, 0xb1, 0xb7, 0xae, 0x20, 0xb2, 0x62, 0x76, 0xa2, 0xe6, 0xe8, 0x15, 0xe4, 0xe4,
	0xe6, 0x81, 0xb8, 0x9e, 0x10, 0x2f, 0xbd, 0xef, 0xd4, 0x4a, 0x07, 0xcf, 0xeb, 0xb7, 0xfc, 0xbf,
	0xc9, 0x9b, 0x41, 0x5d, 0x65, 0xd9, 0x62, 0x34, 0x3e, 0xbb, 0x9e, 0x10, 0x3f, 0x1b, 0x9a, 0x11,
	0x2a, 0xc3, 0x06, 0xe6, 0x9c, 0x08, 0x6f, 0x43, 0x81, 0xeb, 0x09, 0xfa, 0x12, 0x32, 0x78, 0xcc,
	0xa6, 0xb1, 0xf0, 0x32, 0xd2, 0xfc, 0xaa, 0xf2, 0xfd, 0xdb, 0x67, 0xa9, 0x7f, 0xbe, 0x7d, 0xb6,
	0x1b, 0x32, 0x3e, 0x66, 0x9c, 0x47, 0x6f, 0xea, 0x94, 0x35, 0xc6, 0x58, 0x0c, 0xeb, 0xe7, 0x34,
	0x16, 0xbe, 0x59, 0x8d, 0x7e, 0x0e, 0x45, 0xd6, 0xe7, 0x24, 0xb9, 0x22, 0x51, 0x30, 0xc4, 0x7c,
	0xe8, 0x6d, 0x2a, 0xd4, 0x82, 0x35, 0xbe, 0xc6, 0x7c, 0x88, 0x7e, 0x03, 0xde, 0x7c, 0x11, 0x99,
	0x09, 0x92, 0xc4, 0x78, 0x14, 0x0c, 0x09, 0x1d, 0x0c, 0x85, 0x97, 0xdd, 0x77, 0x6a, 0x69, 0x7f,
	0xd7, 0xfa, 0xdb, 0xc6, 0xfd, 0x5a, 0x79, 0xd1, 0xcf, 0xa0, 0xd0, 0xc7, 0xa3, 0x11, 0x13, 0x01,
	0x8d, 0x23, 0x32, 0xf3, 0x72, 0x0a, 0x3d, 0xaf, 0x6d, 0x5d, 0x69, 0x42, 0x07, 0xf0, 0xe8, 0x92,
	0xc6, 0x78, 0x44, 0xbf, 0x23, 0x51, 0x20, 0x2b, 0x60, 0x91, 0x41, 0x21, 0xef, 0xcc, 0x9d, 0xdf,
	0x10, 0x81, 0x0d, 0x2c, 0x85, 0x5d, 0x31, 0x0b, 0x8c, 0x07, 0x0b, 0xca, 0xe2, 0x80, 0x0b, 0x2c,
	0xa6, 0xdc, 0xcb, 0xab, 0xa2, 0x7e, 0x51, 0xbf, 0xb3, 0x69, 0xea, 0x67, 0xb3, 0xce, 0x52, 0x6c,
	0x4f, 0x85, 0xfa, 0x65, 0x71, 0x8b, 0x15, 0xbd, 0x84, 0x1d, 0xca, 0x83, 0xe5, 0xce, 0x0c, 0xf1,
	0x68, 0xe4, 0x15, 0xf6, 0x9d, 0x5a, 0xd6, 0x77, 0x29, 0x6f, 0x49, 0x8f, 0x3a, 0xfc, 0x16, 0x1e,
	0x8d, 0xd0, 0x1f, 0x61, 0x3b, 0x64, 0xf1, 0x25, 0x4d, 0xc6, 0x3a, 0xad, 0x31, 0x8b, 0x88, 0x57,
	0x54, 0x49, 0x35, 0xee, 0x49, 0xaa, 0xb5, 0x14, 0x77, 0xc4, 0x22, 0xe2, 0xbb, 0xe1, 0x0d, 0x0b,
	0x3a, 0x84, 0x8c, 0xf9, 0x9f, 0x65, 0x05, 0xf9, 0xd9, 0x3d, 0x90, 0xa6, 0xb5, 0xcd, 0x1f, 0x34,
	0xb1, 0xd5, 0x6f, 0xa1, 0x24, 0x6b, 0xd9, 0x0c, 0x43, 0xd9, 0x02, 0x34, 0x1e, 0xa0, 0x63, 0xd8,
	0xc1, 0x7d, 0x96, 0x08, 0x7b, 0x02, 0xa6, 0x95, 0x9c, 0x07, 0xb5, 0xd2, 0xb6, 0x09, 0x55, 0x98,
	0x2a, 0xb0, 0x7a, 0x01, 0x79, 0x59, 0x8d, 0x93, 0x89, 0xcc, 0x9c, 0x4b, 0x4e, 0x0c, 0x30, 0x0f,
	0x46, 0x74, 0x4c, 0x35, 0x68, 0xda, 0xcf, 0x0e, 0x30, 0xff, 0x5a, 0xce, 0xd1, 0x0b, 0xd8, 0xa6,
	0x3c, 0xc0, 0x49, 0x9f, 0x8a, 0x04, 0x27, 0xd7, 0xba, 0xbc, 0x6b, 0xaa, 0xbc, 0x5b, 0x94, 0x37,
	0xad, 0x5d, 0xe2, 0x55, 0xff, 0xb2, 0x09, 0xa5, 0x93, 0xa9, 0x58, 0xe6, 0xeb, 0x1e, 0x64, 0x13,
	0x12, 0x12, 0x7a, 0x35, 0x67, 0xec, 0x7c, 0x8e, 0x3e, 0x05, 0xd7, 0x8e, 0xf5, 0xd9, 0x75, 0x2d,
	0x69, 0xb7, 0xac, 0xdd, 0xd2, 0x76, 0x85, 0x99, 0xeb, 0x3f, 0x8e, 0x99, 0x0b, 0x0e, 0xa6, 0xff,
	0x2f, 0x0e, 0x4a, 0xc9, 0xe0, 0x3c, 0x88, 0x59, 0x1c, 0x12, 0xc5, 0xea, 0xb4, 0x9f, 0x15, 0x9c,
	0x1f, 0xcb, 0xf9, 0x6a, 0xed, 0x32, 0x37, 0x6a, 0x67, 0x9c, 0x93, 0x84, 0x86, 0xc4, 0x30, 0x57,
	0x3a, 0x4f, 0xe5, 0x1c, 0xd5, 0xc0, 0x35, 0x4e, 0x96, 0x50, 0x71, 0x1d, 0x5c, 0x12, 0xe2, 0x3d,
	0x56, 0x6b, 0x4a, 0x7a, 0x8d, 0x32, 0x77, 0x08, 0x41, 0x08, 0xd2, 0x8a, 0xfb, 0x59, 0xe5, 0x55,
	0xe3, 0x87, 0x30, 0xf7, 0x2e, 0x59, 0x80, 0x3b, 0x65, 0xe1, 0x09, 0xc8, 0x34, 0x83, 0x29, 0x27,
	0x91, 0xea, 0xe4, 0xb4, 0xbf, 0x39, 0xc0, 0xfc, 0x9c, 0x93, 0x08, 0x1d, 0xc1, 0x0e, 0xb9, 0xbc,
	0x24, 0xa1, 0xa0, 0x57, 0x24, 0x58, 0xfc, 0xb9, 0x47, 0xaa, 0xa2, 0x4f, 0x4d, 0x45, 0x1f, 0xfd,
	0x77, 0x45, 0xbb, 0xb2, 0x13, 0xe7, 0x91, 0x5f, 0xd9, 0x22, 0xd4, 0x6f, 0xc2, 0xe9, 0x42, 0xee,
	0xaa, 0x4d, 0x57, 0xd6, 0xeb, 0x8a, 0x3e, 0x05, 0x90, 0x67, 0x31, 0x99, 0xf6, 0xdf, 0x90, 0x6b,
	0xa5, 0x26, 0x39, 0x5f, 0x9e, 0xce, 0xa9, 0x32, 0xdc, 0x21, 0x3c, 0x85, 0x8f, 0x2d, 0x3c, 0x47,
	0x50, 0x90, 0x54, 0x08, 0x98, 0x26, 0x91, 0xe7, 0xed, 0x3b, 0xb5, 0xfc, 0xc1, 0x8b, 0xfb, 0x44,
	0x64, 0x41, 0x3b, 0x3f, 0x1f, 0x2e, 0x71, 0xf0, 0x56, 0x61, 0x7a, 0xf2, 0x91, 0x84, 0xe9, 0x77,
	0xe9, 0x6c, 0xd1, 0x2d, 0x57, 0xff, 0xbe, 0x06, 0x19, 0x93, 0x7d, 0x73, 0xae, 0x54, 0x8e, 0xda,
	0xe3, 0xd3, 0xfb, 0xf6, 0x08, 0xc5, 0x6c, 0x55, 0xa6, 0xd0, 0x73, 0x28, 0xe9, 0x51, 0x30, 0x26,
	0x9c, 0xe3, 0x01, 0x51, 0xdc, 0xcd, 0xf9, 0x45, 0x6d, 0x3d, 0xd2, 0x46, 0x79, 0x83, 0x91, 0x24,
	0x61, 0xc9, 0x7c, 0x55, 0x46, 0xdf, 0x60, 0xca, 0x68, 0x17, 0x7d, 0x0e, 0xe5, 0x11, 0xe6, 0xe2,
	0x7c, 0x12, 0x61, 0x41, 0x02, 0x41, 0xc7, 0x84, 0x0b, 0x3c, 0x9e, 0x28, 0xa6, 0xaf, 0xfb, 0x3b,
	0x0b, 0xdf, 0x99, 0x75, 0xa1, 0x1a, 0x48, 0xf9, 0x91, 0xd2, 0xe6, 0x93, 0xcb, 0x69, 0x1c, 0x91,
	0x48, 0xd1, 0x5a, 0xab, 0xd2, 0xb2, 0x19, 0xfd, 0x0a, 0xb6, 0xc3, 0x84, 0x60, 0xa9, 0x9e, 0x0b,
	0xe4, 0x0d, 0x85, 0xec, 0x1a, 0xc7, 0x02, 0xf6, 0xd7, 0x50, 0x5e, 0x49, 0x37, 0x48, 0xc8, 0x15,
	0x49, 0x84, 0x61, 0x2f, 0x5a, 0xce, 0xda, 0x57, 0x9e, 0xea, 0x07, 0x07, 0x8a, 0x7a, 0x68, 0xcf,
	0xf2, 0x39, 0x94, 0x74, 0x54, 0x80, 0xa3, 0x28, 0x21, 0x9c, 0x1b, 0xe5, 0x2b, 0x6a, 0x6b, 0x53,
	0x1b, 0xd1, 0x2f, 0xa0, 0xa4, 0x3b, 0x28, 0xb6, 0x9b, 0x68, 0x59, 0x55, 0x7d, 0x75, 0x12, 0x6b,
	0x4c, 0x59, 0x3f, 0x25, 0xe0, 0x73, 0x2c, 0xfd, 0x68, 0x29, 0x28, 0xa3, 0x85, 0x5a, 0xec, 0x68,
	0xab, 0x2c, 0x6b, 0x51, 0xb0, 0x3b, 0xda, 0x32, 0xbf, 0x96, 0x82, 0xab, 0x96, 0x2d, 0xa8, 0xb6,
	0xf1, 0x20, 0x2d, 0x34, 0xf0, 0x96, 0x87, 0xd5, 0x7f, 0xa7, 0xa1, 0xb0, 0xb8, 0x5a, 0xcf, 0x66,
	0xc8, 0x83, 0x4d, 0x55, 0x4b, 0x66, 0x65, 0xde, 0x4e, 0xe5, 0x83, 0x48, 0x4b, 0x94, 0x6e, 0x0f,
	0x3d, 0x41, 0x27, 0x90, 0x53, 0x57, 0xd9, 0x25, 0x21, 0xdc, 0xe4, 0x70, 0x70, 0x77, 0x0e, 0x1f,
	0xde, 0x3e, 0x73, 0xaf, 0xf1, 0x78, 0xf4, 0xdb, 0xea, 0x3c, 0xb0, 0xea, 0x67, 0xe5, 0xb8, 0x43,
	0x08, 0x47, 0xbf, 0x84, 0xad, 0x84, 0x8c, 0xf0, 0x35, 0x89, 0x6e, 0x74, 0x5a, 0xc9, 0x98, 0x6d,
	0x11, 0x3a, 0x90, 0x0f, 0x43, 0x31, 0xb3, 0xc2, 0x90, 0x55, 0xbc, 0x7d, 0x7e, 0x4f, 0xff, 0x9b,
	0xde, 0x87, 0x70, 0xce, 0x03, 0xd4, 0x83, 0x12, 0xd5, 0xf7, 0x77, 0x30, 0x51, 0x77, 0x9d, 0xd2,
	0xe0, 0xfc, 0x43, 0x2f, 0x7d, 0x7d, 0x3f, 0xfa, 0x45, 0xba, 0xf2, 0xbc, 0xbd, 0x80, 0x2d, 0x66,
	0x2e, 0x50, 0x8b, 0x0a, 0xfb, 0xeb, 0xb5, 0xfc, 0xc1, 0xcb, 0x7b, 0x50, 0x57, 0xaf, 0x5d, 0xbf,
	0xc4, 0x56, 0xaf, 0xe1, 0x04, 0x9e, 0xa8, 0x17, 0x75, 0xc8, 0x46, 0x41, 0xc8, 0x62, 0x91, 0xe0,
	0x50, 0x04, 0x57, 0x24, 0xe1, 0x94, 0xc5, 0xe6, 0x51, 0xf6, 0xe5, 0x3d, 0x3b, 0x9c, 0x9a, 0xf8,
	0x96, 0x09, 0xbf, 0xd0, 0xd1, 0xfe, 0xe3, 0xc9, 0xed, 0x0e, 0xf4, 0x87, 0x79, 0x53, 0x5a, 0x8d,
	0x2c, 0x3c, 0xa8, 0x40, 0x2b, 0x64, 0x7a, 0x95, 0x96, 0x5d, 0x61, 0x1b, 0xd9, 0x18, 0x5f, 0xfc,
	0x09, 0x60, 0xa1, 0x48, 0x08, 0x41, 0xe9, 0x94, 0xc4, 0x11, 0x8d, 0x07, 0xa6, 0xb6, 0x6e, 0x0a,
	0xed, 0xc0, 0x96, 0xb1, 0xd9, 0xca, 0xb8, 0x0e, 0xda, 0x86, 0xa2, 0x9d, 0x1d, 0xd1, 0x98, 0x44,
	0xee, 0xba, 0x34, 0x99, 0x75, 0x7a, 0x5b, 0x37, 0x8d, 0x0a, 0x90, 0xd5, 0x63, 0x12, 0xb9, 0x1b,
	0x28, 0x0f, 0x9b, 0x4d, 0xfd, 0x80, 0x72, 0x33, 0x7b, 0xe9, 0xbf, 0xfd, 0xb5, 0xe2, 0xbc, 0xf8,
	0x3d, 0x94, 0x6f, 0xbb, 0x28, 0x90, 0x0b, 0x85, 0x63, 0x26, 0x3a, 0xf6, 0x41, 0xec, 0xa6, 0x50,
	0x11, 0x72, 0x8b, 0xa9, 0x23, 0x91, 0xdb, 0x33, 0x12, 0x4e, 0x25, 0xd8, 0x9a, 0x01, 0xfb, 0x0c,
	0xdc, 0x9b, 0x02, 0x8e, 0xb2, 0x90, 0xee, 0x35, 0x3b, 0x6d, 0x37, 0x25, 0x47, 0x9d, 0x66, 0xef,
	0xcc, 0x75, 0xcc, 0xea, 0x6f, 0xe7, 0xdf, 0x43, 0x66, 0xcf, 0x3c, 0x6c, 0xf6, 0xce, 0x5b, 0xad,
	0x76, 0xaf, 0xe7, 0xa6, 0x50, 0x05, 0xf6, 0xba, 0xc7, 0xbd, 0xf3, 0x4e, 0xa7, 0xdb, 0xea, 0xb6,
	0x8f, 0xcf, 0x82, 0xc3, 0xf6, 0xe9, 0x49, 0xaf, 0x7b, 0x76, 0xe2, 0x07, 0x9d, 0x76, 0xdb, 0x75,
	0xd0, 0x4f, 0xc1, 0xeb, 0x1e, 0x5f, 0x34, 0xbf, 0xee, 0x1e, 0x06, 0x7e, 0xbb, 0xd5, 0xee, 0x5e,
	0xb4, 0xfd, 0xa0, 0x79, 0x78, 0xe8, 0xcb, 0x68, 0x9b, 0x4f, 0x03, 0x1e, 0xff, 0x8f, 0x93, 0x46,
	0x19, 0x58, 0xbb, 0xf8, 0xdc, 0x4d, 0xa9, 0xdf, 0x03, 0x9b, 0xd2, 0xab, 0xaf, 0xbe, 0x7f, 0x57,
	0x71, 0x7e, 0x78, 0x57, 0x71, 0xfe, 0xf5, 0xae, 0xe2, 0xfc, 0xf9, 0x7d, 0x25, 0xf5, 0xc3, 0xfb,
	0x4a, 0xea, 0x1f, 0xef, 0x2b, 0xa9, 0x6f, 0x5e, 0x0e, 0xa8, 0x18, 0x4e, 0xfb, 0xf5, 0x90, 0x8d,
	0xd5, 0x67, 0xde, 0x4b, 0xfd, 0xc5, 0x17, 0xb3, 0x88, 0x34, 0x66, 0xcb, 0x1f, 0x96, 0xf2, 0x55,
	0xc7, 0xfb, 0x19, 0xd5, 0x48, 0x5f, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xa7, 0x19, 0xe1, 0x8a,
	0x86, 0x0e, 0x00, 0x00,
}

func (m *InboundParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InboundParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ConfirmationMode != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.ConfirmationMode))
		i--
		dAtA[i] = 0x68
	}
	if m.IsCrossChainCall {
		i--
		if m.IsCrossChainCall {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.TxFinalizationStatus != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.TxFinalizationStatus))
		i--
		dAtA[i] = 0x58
	}
	if m.FinalizedZetaHeight != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.FinalizedZetaHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.BallotIndex) > 0 {
		i -= len(m.BallotIndex)
		copy(dAtA[i:], m.BallotIndex)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.BallotIndex)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ObservedExternalHeight != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.ObservedExternalHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ObservedHash) > 0 {
		i -= len(m.ObservedHash)
		copy(dAtA[i:], m.ObservedHash)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.ObservedHash)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Asset) > 0 {
		i -= len(m.Asset)
		copy(dAtA[i:], m.Asset)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.Asset)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CoinType != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.CoinType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TxOrigin) > 0 {
		i -= len(m.TxOrigin)
		copy(dAtA[i:], m.TxOrigin)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.TxOrigin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SenderChainId != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.SenderChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZetaAccounting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZetaAccounting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZetaAccounting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AbortedZetaAmount.Size()
		i -= size
		if _, err := m.AbortedZetaAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CallOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsArbitraryCall {
		i--
		if m.IsArbitraryCall {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.GasLimit != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OutboundParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutboundParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutboundParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfirmationMode != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.ConfirmationMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.CallOptions != nil {
		{
			size, err := m.CallOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.GasPriorityFee) > 0 {
		i -= len(m.GasPriorityFee)
		copy(dAtA[i:], m.GasPriorityFee)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.GasPriorityFee)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.EffectiveGasLimit != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.EffectiveGasLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	{
		size := m.EffectiveGasPrice.Size()
		i -= size
		if _, err := m.EffectiveGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if m.GasUsed != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TxFinalizationStatus != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.TxFinalizationStatus))
		i--
		dAtA[i] = 0x60
	}
	if len(m.TssPubkey) > 0 {
		i -= len(m.TssPubkey)
		copy(dAtA[i:], m.TssPubkey)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.TssPubkey)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ObservedExternalHeight != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.ObservedExternalHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.BallotIndex) > 0 {
		i -= len(m.BallotIndex)
		copy(dAtA[i:], m.BallotIndex)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.BallotIndex)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GasPrice) > 0 {
		i -= len(m.GasPrice)
		copy(dAtA[i:], m.GasPrice)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.GasPrice)))
		i--
		dAtA[i] = 0x3a
	}
	if m.GasLimit != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.TssNonce != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.TssNonce))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.CoinType != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.CoinType))
		i--
		dAtA[i] = 0x18
	}
	if m.ReceiverChainId != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.ReceiverChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessageRevert) > 0 {
		i -= len(m.ErrorMessageRevert)
		copy(dAtA[i:], m.ErrorMessageRevert)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.ErrorMessageRevert)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedTimestamp != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.CreatedTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.IsAbortRefunded {
		i--
		if m.IsAbortRefunded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.LastUpdateTimestamp != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.LastUpdateTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StatusMessage) > 0 {
		i -= len(m.StatusMessage)
		copy(dAtA[i:], m.StatusMessage)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.StatusMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RevertOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevertOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevertOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RevertGasLimit.Size()
		i -= size
		if _, err := m.RevertGasLimit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.RevertMessage) > 0 {
		i -= len(m.RevertMessage)
		copy(dAtA[i:], m.RevertMessage)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.RevertMessage)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AbortAddress) > 0 {
		i -= len(m.AbortAddress)
		copy(dAtA[i:], m.AbortAddress)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.AbortAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CallOnRevert {
		i--
		if m.CallOnRevert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.RevertAddress) > 0 {
		i -= len(m.RevertAddress)
		copy(dAtA[i:], m.RevertAddress)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.RevertAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RevertOptions.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.ProtocolContractVersion != 0 {
		i = encodeVarintCrossChainTx(dAtA, i, uint64(m.ProtocolContractVersion))
		i--
		dAtA[i] = 0x58
	}
	if len(m.OutboundParams) > 0 {
		for iNdEx := len(m.OutboundParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutboundParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.InboundParams != nil {
		{
			size, err := m.InboundParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CctxStatus != nil {
		{
			size, err := m.CctxStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.RelayedMessage) > 0 {
		i -= len(m.RelayedMessage)
		copy(dAtA[i:], m.RelayedMessage)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.RelayedMessage)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.ZetaFees.Size()
		i -= size
		if _, err := m.ZetaFees.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChainTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintCrossChainTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossChainTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChainTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InboundParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.SenderChainId != 0 {
		n += 1 + sovCrossChainTx(uint64(m.SenderChainId))
	}
	l = len(m.TxOrigin)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.CoinType != 0 {
		n += 1 + sovCrossChainTx(uint64(m.CoinType))
	}
	l = len(m.Asset)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChainTx(uint64(l))
	l = len(m.ObservedHash)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.ObservedExternalHeight != 0 {
		n += 1 + sovCrossChainTx(uint64(m.ObservedExternalHeight))
	}
	l = len(m.BallotIndex)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.FinalizedZetaHeight != 0 {
		n += 1 + sovCrossChainTx(uint64(m.FinalizedZetaHeight))
	}
	if m.TxFinalizationStatus != 0 {
		n += 1 + sovCrossChainTx(uint64(m.TxFinalizationStatus))
	}
	if m.IsCrossChainCall {
		n += 2
	}
	if m.ConfirmationMode != 0 {
		n += 1 + sovCrossChainTx(uint64(m.ConfirmationMode))
	}
	if m.Status != 0 {
		n += 2 + sovCrossChainTx(uint64(m.Status))
	}
	return n
}

func (m *ZetaAccounting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AbortedZetaAmount.Size()
	n += 1 + l + sovCrossChainTx(uint64(l))
	return n
}

func (m *CallOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GasLimit != 0 {
		n += 1 + sovCrossChainTx(uint64(m.GasLimit))
	}
	if m.IsArbitraryCall {
		n += 2
	}
	return n
}

func (m *OutboundParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.ReceiverChainId != 0 {
		n += 1 + sovCrossChainTx(uint64(m.ReceiverChainId))
	}
	if m.CoinType != 0 {
		n += 1 + sovCrossChainTx(uint64(m.CoinType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChainTx(uint64(l))
	if m.TssNonce != 0 {
		n += 1 + sovCrossChainTx(uint64(m.TssNonce))
	}
	if m.GasLimit != 0 {
		n += 1 + sovCrossChainTx(uint64(m.GasLimit))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = len(m.BallotIndex)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.ObservedExternalHeight != 0 {
		n += 1 + sovCrossChainTx(uint64(m.ObservedExternalHeight))
	}
	l = len(m.TssPubkey)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.TxFinalizationStatus != 0 {
		n += 1 + sovCrossChainTx(uint64(m.TxFinalizationStatus))
	}
	if m.GasUsed != 0 {
		n += 2 + sovCrossChainTx(uint64(m.GasUsed))
	}
	l = m.EffectiveGasPrice.Size()
	n += 2 + l + sovCrossChainTx(uint64(l))
	if m.EffectiveGasLimit != 0 {
		n += 2 + sovCrossChainTx(uint64(m.EffectiveGasLimit))
	}
	l = len(m.GasPriorityFee)
	if l > 0 {
		n += 2 + l + sovCrossChainTx(uint64(l))
	}
	if m.CallOptions != nil {
		l = m.CallOptions.Size()
		n += 2 + l + sovCrossChainTx(uint64(l))
	}
	if m.ConfirmationMode != 0 {
		n += 2 + sovCrossChainTx(uint64(m.ConfirmationMode))
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCrossChainTx(uint64(m.Status))
	}
	l = len(m.StatusMessage)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.LastUpdateTimestamp != 0 {
		n += 1 + sovCrossChainTx(uint64(m.LastUpdateTimestamp))
	}
	if m.IsAbortRefunded {
		n += 2
	}
	if m.CreatedTimestamp != 0 {
		n += 1 + sovCrossChainTx(uint64(m.CreatedTimestamp))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = len(m.ErrorMessageRevert)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	return n
}

func (m *RevertOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RevertAddress)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.CallOnRevert {
		n += 2
	}
	l = len(m.AbortAddress)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = len(m.RevertMessage)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = m.RevertGasLimit.Size()
	n += 1 + l + sovCrossChainTx(uint64(l))
	return n
}

func (m *CrossChainTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	l = m.ZetaFees.Size()
	n += 1 + l + sovCrossChainTx(uint64(l))
	l = len(m.RelayedMessage)
	if l > 0 {
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.CctxStatus != nil {
		l = m.CctxStatus.Size()
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if m.InboundParams != nil {
		l = m.InboundParams.Size()
		n += 1 + l + sovCrossChainTx(uint64(l))
	}
	if len(m.OutboundParams) > 0 {
		for _, e := range m.OutboundParams {
			l = e.Size()
			n += 1 + l + sovCrossChainTx(uint64(l))
		}
	}
	if m.ProtocolContractVersion != 0 {
		n += 1 + sovCrossChainTx(uint64(m.ProtocolContractVersion))
	}
	l = m.RevertOptions.Size()
	n += 1 + l + sovCrossChainTx(uint64(l))
	return n
}

func sovCrossChainTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChainTx(x uint64) (n int) {
	return sovCrossChainTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InboundParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InboundParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InboundParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChainId", wireType)
			}
			m.SenderChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderChainId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			m.CoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinType |= coin.CoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedExternalHeight", wireType)
			}
			m.ObservedExternalHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedExternalHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BallotIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BallotIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedZetaHeight", wireType)
			}
			m.FinalizedZetaHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedZetaHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxFinalizationStatus", wireType)
			}
			m.TxFinalizationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxFinalizationStatus |= TxFinalizationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCrossChainCall", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCrossChainCall = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmationMode", wireType)
			}
			m.ConfirmationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmationMode |= ConfirmationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InboundStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZetaAccounting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZetaAccounting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZetaAccounting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortedZetaAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AbortedZetaAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArbitraryCall", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArbitraryCall = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutboundParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutboundParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutboundParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverChainId", wireType)
			}
			m.ReceiverChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiverChainId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			m.CoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinType |= coin.CoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TssNonce", wireType)
			}
			m.TssNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TssNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BallotIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BallotIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedExternalHeight", wireType)
			}
			m.ObservedExternalHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservedExternalHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TssPubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TssPubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxFinalizationStatus", wireType)
			}
			m.TxFinalizationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxFinalizationStatus |= TxFinalizationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EffectiveGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveGasLimit", wireType)
			}
			m.EffectiveGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectiveGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPriorityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPriorityFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallOptions == nil {
				m.CallOptions = &CallOptions{}
			}
			if err := m.CallOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmationMode", wireType)
			}
			m.ConfirmationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmationMode |= ConfirmationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CctxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTimestamp", wireType)
			}
			m.LastUpdateTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAbortRefunded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAbortRefunded = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTimestamp", wireType)
			}
			m.CreatedTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessageRevert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessageRevert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevertOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevertOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevertOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevertAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallOnRevert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CallOnRevert = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbortAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevertMessage = append(m.RevertMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.RevertMessage == nil {
				m.RevertMessage = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertGasLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RevertGasLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZetaFees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ZetaFees.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CctxStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CctxStatus == nil {
				m.CctxStatus = &Status{}
			}
			if err := m.CctxStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InboundParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InboundParams == nil {
				m.InboundParams = &InboundParams{}
			}
			if err := m.InboundParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutboundParams = append(m.OutboundParams, &OutboundParams{})
			if err := m.OutboundParams[len(m.OutboundParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolContractVersion", wireType)
			}
			m.ProtocolContractVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolContractVersion |= ProtocolContractVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RevertOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChainTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChainTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChainTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChainTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChainTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChainTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChainTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChainTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChainTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChainTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChainTx = fmt.Errorf("proto: unexpected end of group")
)
