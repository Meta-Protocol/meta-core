package tss

import (
	"encoding/json"
	"os"
	"path/filepath"

	"github.com/bnb-chain/tss-lib/ecdsa/keygen"
	"github.com/multiformats/go-multiaddr"
	"github.com/pkg/errors"
	tsscommon "gitlab.com/thorchain/tss/go-tss/common"
)

const (
	Port    = 6668
	Version = "0.14.0"
	Algo    = tsscommon.ECDSA
)

// MultiAddressFromString parses a string into a slice of addresses (for convenience).
func MultiAddressFromString(peer string) ([]multiaddr.Multiaddr, error) {
	if peer == "" {
		return nil, errors.New("peer is empty")
	}

	ma, err := multiaddr.NewMultiaddr(peer)
	if err != nil {
		return nil, err
	}

	return []multiaddr.Multiaddr{ma}, nil
}

// ResolvePreParamsFromPath resolves TSS pre-params from json config by path.
// Error indicates that the pre-params file is not found or invalid.
// FYI: pre-params are generated by keygen.GeneratePreParams.
func ResolvePreParamsFromPath(path string) (*keygen.LocalPreParams, error) {
	if path == "" {
		return nil, errors.New("pre-params path is empty")
	}

	path = filepath.Clean(path)

	raw, err := os.ReadFile(path)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to read pre-params at %q", path)
	}

	var pp keygen.LocalPreParams
	if err = json.Unmarshal(raw, &pp); err != nil {
		return nil, errors.Wrapf(err, "unable to decode pre-params at %q", path)
	}

	return &pp, nil
}
